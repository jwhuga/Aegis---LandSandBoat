#
# During CMake configuration/build this script is automatically run, generating build/generated/ipc_stubs.h
#


# fmt: off
import io
import os
import sys


# TODO: Make this generic so you can specify an output filename, namespace name, interface name, enum name, etc.


# Define the struct names that will be used to generate build/generated/ipc_stubs.h
IPC_STRUCT_NAMES = [
    "EmptyStruct",

    "CharLogin",
    "CharZone",
    "CharVarUpdate",

    "ChatMessageTell",
    "ChatMessageParty",
    "ChatMessageAlliance",
    "ChatMessageLinkshell",
    "ChatMessageUnity",
    "ChatMessageYell",
    "ChatMessageAssist",
    "ChatMessageServerMessage",
    "ChatMessageCustom",

    "PartyInvite",
    "PartyInviteResponse",
    "PartyReload",
    "PartyDisband",

    "AllianceReload",
    "AllianceDissolve",

    "PlayerKick",

    "MessageStandard",
    "MessageSystem",

    "LinkshellRankChange",
    "LinkshellRemove",
    "LinkshellSetMessage",

    "LuaFunction",

    "KillSession",

    "ConquestEvent",
    "BesiegedEvent",
    "CampaignEvent",
    "ColonizationEvent",

    "EntityInformationRequest",
    "EntityInformationResponse",

    "SendPlayerToLocation",

    "AssistChannelEvent",
]


def generate_ipc_stubs(output_dir, struct_names):
    output_path = os.path.normpath(os.path.join(output_dir, "generated"))
    print(f"Generating ipc stubs...")
    print(f"Output directory: {output_path}")

    os.makedirs(output_path, exist_ok=True)

    ipc_stub_file = os.path.join(output_path, "ipc_stubs.h")
    with io.StringIO() as stream:
        stream.write(f"// This file is auto-generated by tools/generate_ipc_stubs.py\n")
        stream.write(f"// Do not modify this file directly.\n\n")
        stream.write(f"#pragma once\n\n")
        stream.write(f"#include <array>\n")
        stream.write(f"#include <cstdint>\n")
        stream.write(f"#include <span>\n")
        stream.write(f"#include <string>\n")
        stream.write(f"#include <string_view>\n")
        stream.write(f"#include <type_traits>\n\n")
        stream.write(f"#include \"common/ipc_structs.h\"\n")
        stream.write(f"#include \"common/ipp.h\"\n")
        stream.write(f"#include \"common/logging.h\"\n")
        stream.write(f"#include \"common/tracy.h\"\n\n")
        stream.write(f"namespace ipc\n{{\n\n")

        generate_message_type_enum(stream, struct_names)
        generate_struct_completion_traits(stream)
        generate_enum_types(stream, struct_names)
        generate_enum_to_string_templates(stream, struct_names)
        generate_enum_to_string_function(stream, struct_names)
        generate_message_handler_crtp_base(stream, struct_names)

        stream.write(f"}} // namespace ipc\n")
        generated_content = stream.getvalue()

    needs_write = True
    if os.path.exists(ipc_stub_file):
        with open(ipc_stub_file, "r") as f_read:
            existing_content = f_read.read()
        if generated_content == existing_content:
            needs_write = False

    if needs_write:
        with open(ipc_stub_file, "w") as f_write:
            f_write.write(generated_content)
            print(f"File generated.")
    else:
        print(f"File already generated. No update necessary.")

def output_header(file, str):
    file.write(f"//\n")
    file.write(f"// {str}\n")
    file.write(f"//\n\n")


def generate_message_type_enum(file, struct_names):
    output_header(file, "Message Type Enum")

    max_name_length = max(len(name) for name in struct_names)

    file.write(f"enum class MessageType : uint8_t\n{{\n")

    file.write(f"    // 0 is reserved for unknown messages\n\n")

    for idx, name in enumerate(struct_names, 1):
        file.write(f"    {name.ljust(max_name_length)} = {idx},\n")

    file.write(f"}};\n\n")


def generate_struct_completion_traits(file):
    output_header(file, "Struct Completion Traits")

    file.write(f"template <typename T, typename = void>\n")
    file.write(f"struct is_struct_complete : std::false_type {{}};\n\n")

    file.write(f"template <typename T>\n")
    file.write(f"struct is_struct_complete<T, std::void_t<decltype(sizeof(T))>> : std::true_type {{}};\n\n")


def generate_enum_types(file, struct_names):
    output_header(file, "Enum Type Templates")

    file.write(f"template <typename T>\n")
    file.write(f"struct EnumType;\n\n")

    file.write(f"// Specializations for each IPC struct:\n")
    for name in struct_names:
        file.write(f"template <>\n")
        file.write(f"struct EnumType<{name}>\n")
        file.write(f"{{\n")
        file.write(f"    static constexpr MessageType value = MessageType::{name};\n")
        file.write(f"}};\n\n")

    file.write(f"template <typename T>\n")
    file.write(f"constexpr MessageType EnumTypeV = EnumType<std::decay_t<T>>::value;\n\n")


def generate_enum_to_string_templates(file, struct_names):
    output_header(file, "Enum to String Templates")

    file.write(f"template <typename T>\n")
    file.write(f"struct EnumToString;\n\n")

    for name in struct_names:
        file.write(f"template <>\n")
        file.write(f"struct EnumToString<{name}>\n")
        file.write(f"{{\n")
        file.write(f"    static constexpr const char* value = \"{name}\";\n")
        file.write(f"}};\n\n")

    file.write(f"template <typename T>\n")
    file.write(f"constexpr const char* toStringV = EnumToString<std::decay_t<T>>::value;\n\n")


def generate_enum_to_string_function(file, struct_names):
    output_header(file, "Enum to String Function")

    file.write(f"constexpr std::array<const char*, {len(struct_names) + 1}> messageTypeStrings =\n")
    file.write(f"{{\n")
    for name in struct_names:
        file.write(f"    \"{name}\",\n")
    file.write(f"}};\n\n")

    file.write(f"inline std::string_view toString(MessageType type)\n")
    file.write(f"{{\n")
    file.write(f"    const auto index = static_cast<uint8_t>(type);\n")
    file.write(f"    if (index >= 1 && index <= messageTypeStrings.size())\n")
    file.write(f"    {{\n")
    file.write(f"        return messageTypeStrings[index - 1];\n")
    file.write(f"    }}\n")
    file.write(f"    return \"Unknown\";\n")
    file.write(f"}}\n\n")

def generate_message_handler_crtp_base(file, struct_names):
    output_header(file, "Message Handler CRTP Base")

    file.write(f"template <typename Derived>\n")
    file.write(f"class IPCMessageHandlerBase\n")
    file.write(f"{{\n")
    file.write(f"public:\n")
    file.write(f"    void handleMessage(const IPP& ipp, const std::span<uint8_t> message)\n")
    file.write(f"    {{\n")
    file.write(f"        TracyZoneScoped;\n\n")
    file.write(f"        const auto messageType = static_cast<MessageType>(message[0]);\n")
    file.write(f"        switch (messageType)\n")
    file.write(f"        {{\n")

    for name in struct_names:
        file.write(f"            case MessageType::{name}:\n")
        file.write(f"            {{\n")
        file.write(f"                const auto object = ipc::fromBytesWithHeader<{name}>(message);\n")
        file.write(f"                if (!object.has_value())\n")
        file.write(f"                {{\n")
        file.write(f"                    ShowError(\"Failed to deserialize {name} message.\");\n")
        file.write(f"                    break;\n")
        file.write(f"                }}\n")
        file.write(f"                static_cast<Derived*>(this)->handleMessage_{name}(ipp, *object);\n")
        file.write(f"            }}\n")
        file.write(f"            break;\n")

    file.write(f"            default:\n")
    file.write(f"            {{\n")
    file.write(f"                static_cast<Derived*>(this)->handleUnknownMessage(ipp, message);\n")
    file.write(f"            }}\n")
    file.write(f"            break;\n")
    file.write(f"        }}\n")
    file.write(f"    }}\n\n")

    for name in struct_names:
        file.write(f"    // Derived must implement: void handleMessage_{name}(const IPP& ipp, const ipc::{name}& message);\n")
    file.write(f"    // Derived must implement: void handleUnknownMessage(const IPP& ipp, const std::span<uint8_t> message);\n")
    file.write(f"}};\n\n")


if __name__ == "__main__":
    current_path = os.path.dirname(os.path.realpath(__file__))
    output_directory = os.path.join(current_path, sys.argv[1])

    generate_ipc_stubs(output_directory, IPC_STRUCT_NAMES)
